The opinionated deployment tool - automation and WSGI

Wishlist
--------

+ Easy to get up and going locally with a Django project - ideally 
one or two commands until there's an activated virtualenv and my 
preferred Django project skeleton is inside TextMate. [DONE]
+ A directory of deployment configuration where I define the caching 
schema, number of workers, staging and live URL's, perhaps super user
accounts. [DONE you define workers a main domain and aliases]
+ Command line tools to load and dump data from _all_ sources 
(PostgreSQL, redis, CouchDB, user uploaded files etc.). Some S3 
backup points perhaps. Something like the Bundle feature in Heroku.
[Support is planned for PostgreSQL, redis and files]
+ Easy migration strategy for scaling to multiple servers.
+ Easy inspection of data and node health. [PLANNED]
+ Easy destroy/create of nodes. [DONE]
+ Easy running one-off commands in the right environment on a remote 
server (think Django syncdb). Or easy dropping into a remote bash 
shell with everything set up for a project.
+ Easy local testing - both quick for code-alt+tab-refresh action and 
a full stack VirtualBox/VMWare deployment. [When libcloud gets a 
VirtualBox driver this will be easy]
+ Easy CDN management at the application level - Environments should 
be aware of how to serve static media. [This might be hard]
+ Easy to venture off the beaten path - this is the enemy of 
automation! [Server scripts and project init skeleton is template 
based - user can define own template directory to overwrite specific
files]
+ Easy to define complimentary processes (like worker daemons). 
[Haven't given this much tought]

Design notes
------------

Admin is the computer where kraftwerk is instantiated. The admin 
commissions and interacts with nodes. The admin uploads projects to 
nodes. Server nodes should not require a kraftwerk library. What about 
uploads? ...

Server nodes are referred to by their hostname (can be anything because 
kraftwerk touches your /etc/hosts). 

Projects are referred to by their root folder name. 

Services should be able to dump and load data per project. These
actions are initiated by the admin.

The kraftwerk cli is path aware. If executed inside a project 
directory it can interact with that project.

The init command creates an empty or almost empty WSGI Python 
project. The user can configure a secondary project template 
directory to overwrite templates. Currently kraftwerk only allows the
user to overwrite files - not whole structures.

Strategy
--------

By formalizing some project conventions and the server stack, in 
theory large chunks of the deployment process can be automated.
The creation of nodes follows a 'push' model. This means that servers
are commissioned from your client machine. Node interaction and 
commissioning is done with libcloud. 

An admin YAML config file is saved in the user's home folder. The 
user can specify libcloud access credentials.

Projects have YAML config files that specify a number of things. Look
at kraftwerk/kraftwerk/templates/project/kraftwerk.yaml for example
parameters. The user can overwrite a number of things by specifying a 
directory of config files. Kraftwerk uses template engine to generate
shell scripts and project skeletons. User defined templates take 
precedence in template selection. In the future whole project 
skeleton structures could be overwritten in a clean fashion.

Setup project vs. Deploy project
--------------------------------

Setup and deployment of projects is run from the same non-
destructive command (setup-project). Kraftwerk detects new projects
and runs setup for each defined service. Kraftwerk makes a 
distinction between reloading and restarting services.

Ideal API
---------

# kraftwerk create-node myserver
> Looks like you haven't used kraftwerk before ... [some init]
> Waiting for node ...
> Edit /etc/hosts ? [y/n] y
> root SSH access is now ready
# kraftwerk init myproject
> myproject virtualenv is ready
# cd myproject
# source bin/activate
> kraftwerk setup-project --node myserver
> config validates
> site is ready!

Server Setup
------------

runit, nginx, gunicorn, virtualenv
Python stack: Crypto, PIL, DB drivers

`web` user and a `/web` directory to contain project code and uploads

Inspiration
-----------

Heroku, Silver Lining, marcdoc